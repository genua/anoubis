/*
 * Copyright (c) 2007 GeNUA mbH <info@genua.de>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * NOTE CEH: We had lot's of problems with the escalation notifies where
 * NOTE CEH: several notifiers where shown at the same time even though
 * NOTE CEH: we only ever create a singe one. This is apparently because
 * NOTE CEH: the gtk events generated by libnotify are not processed
 * NOTE CEH: properly or not in a timely manner.
 * NOTE CEH: We work around this by forcing a wxWidgets Yield() at several
 * NOTE CEH: places which among other things causes which pending gtk events
 * NOTE CEH: to be processed.
 */

#include <wx/icon.h>
#include <wx/event.h>
#include <wx/string.h>

#include <libnotify/notify.h>
#include "config.h"
#ifdef NEEDBSDCOMPAT
#include <bsdcompat.h>
#endif

#include "AnEvents.h"
#include "JobCtrl.h"
#include "main.h"
#include "TrayIcon.h"

#define MAX_MESSAGE	128
#define MAX_PATH	1024
#define ONE_SECOND	1000

BEGIN_EVENT_TABLE(TrayIcon, wxTaskBarIcon)
	EVT_MENU(GUI_EXIT, TrayIcon::OnGuiExit)
	EVT_MENU(GUI_RESTORE, TrayIcon::OnGuiRestore)
	EVT_TASKBAR_LEFT_DOWN(TrayIcon::OnLeftButtonClick)
END_EVENT_TABLE()


TrayIcon::TrayIcon(void)
{
	AnEvents	*anEvents;
	JobCtrl		*jobCtrl;

	iconNormal_    = wxGetApp().loadIcon(wxT("ModAnoubis_black_48.png"));
	iconMsgProblem_ = wxGetApp().loadIcon(wxT("ModAnoubis_alert_48.png"));
	iconMsgQuestion_ =
	    wxGetApp().loadIcon(wxT("ModAnoubis_question_48.png"));

	messageAlertCount_ = 0;
	messageEscalationCount_ = 0;
	daemon_ = _("none");

	/* these defaults comply with the wxforrmbuilder settings */
	sendAlert_ = false;
	sendEscalation_ = true;
	escalationTimeout_ = 0;
	alertTimeout_ = 10;

	notify_init("Anoubis");
	notification = notify_notification_new("Anoubis", "", NULL, NULL);
	anEvents = AnEvents::getInstance();
	jobCtrl = JobCtrl::getInstance();

	update();

	jobCtrl->Connect(anEVT_COM_CONNECTION,
	    wxCommandEventHandler(TrayIcon::OnConnectionStateChange),
	    NULL, this);
	anEvents->Connect(anEVT_OPEN_ALERTS,
	    wxCommandEventHandler(TrayIcon::OnOpenAlerts), NULL, this);
	anEvents->Connect(anEVT_OPEN_ESCALATIONS,
	    wxCommandEventHandler(TrayIcon::OnOpenEscalations), NULL, this);
	anEvents->Connect(anEVT_LOGVIEWER_SHOW,
	    wxCommandEventHandler(TrayIcon::OnLogViewerShow), NULL, this);
	anEvents->Connect(anEVT_ESCALATIONNOTIFY_OPTIONS,
	    wxCommandEventHandler(TrayIcon::OnEscalationSettingsChanged), NULL,
	    this);
	anEvents->Connect(anEVT_ALERTNOTIFY_OPTIONS,
	    wxCommandEventHandler(TrayIcon::OnAlertSettingsChanged), NULL,
	    this);
}

TrayIcon::~TrayIcon(void)
{
	AnEvents *anEvents;

	anEvents = AnEvents::getInstance();

	/* free notification object */
	g_object_unref(G_OBJECT(notification));
	notify_uninit();

	anEvents->Disconnect(anEVT_OPEN_ALERTS,
	    wxCommandEventHandler(TrayIcon::OnOpenAlerts), NULL, this);
	anEvents->Disconnect(anEVT_OPEN_ESCALATIONS,
	    wxCommandEventHandler(TrayIcon::OnOpenEscalations), NULL, this);
	anEvents->Disconnect(anEVT_LOGVIEWER_SHOW,
	    wxCommandEventHandler(TrayIcon::OnLogViewerShow), NULL, this);
	anEvents->Disconnect(anEVT_ESCALATIONNOTIFY_OPTIONS,
	    wxCommandEventHandler(TrayIcon::OnEscalationSettingsChanged), NULL,
	    this);
	anEvents->Disconnect(anEVT_ALERTNOTIFY_OPTIONS,
	    wxCommandEventHandler(TrayIcon::OnAlertSettingsChanged), NULL,
	    this);

	delete iconNormal_;
	delete iconMsgProblem_;
	delete iconMsgQuestion_;
}

void
TrayIcon::OnConnectionStateChange(wxCommandEvent& event)
{
	daemon_ = event.GetString();
	update();
	wxGetApp().Yield(false);	/* Process pending libnotify events. */
	event.Skip();
}

void
TrayIcon::OnOpenAlerts(wxCommandEvent& event)
{
	messageAlertCount_ = event.GetInt();
	update();
	wxGetApp().Yield(false);	/* Process pending libnotify events. */
	event.Skip();
}

void
TrayIcon::OnOpenEscalations(wxCommandEvent& event)
{
	messageEscalationCount_ = event.GetInt();
	update();
	wxGetApp().Yield(false);	/* Process pending libnotify events. */
	event.Skip();
}

/*
 * [MPI] has decided that we clear Alerts on opening the LogViewer.
 */
void
TrayIcon::OnLogViewerShow(wxCommandEvent& event)
{
	if(event.GetInt()) {
		messageAlertCount_ = 0;
		update();
	}
	event.Skip();
}

void
TrayIcon::OnLeftButtonClick(wxTaskBarIconEvent&)
{
	if (messageEscalationCount_ > 0 || messageAlertCount_ > 0) {
		this->systemNotifyCallback();
	} else {
		wxCommandEvent  showEvent(anEVT_MAINFRAME_SHOW);

		if (wxGetApp().showingMainFrame())
			showEvent.SetInt(false);
		else
			showEvent.SetInt(true);

		wxPostEvent(AnEvents::getInstance(), showEvent);
	}
}

void
TrayIcon::OnGuiRestore(wxCommandEvent&)
{
	wxCommandEvent  showEvent(anEVT_MAINFRAME_SHOW);

	showEvent.SetInt(true);

	wxPostEvent(AnEvents::getInstance(), showEvent);
}

void
TrayIcon::OnGuiExit(wxCommandEvent&)
{
	wxGetApp().quit();
}

void
TrayIcon::OnEscalationSettingsChanged(wxCommandEvent& event)
{
	if (event.GetInt() > 0) {
		sendEscalation_ = true;
	} else {
		sendEscalation_ = false;
	}
	escalationTimeout_ = event.GetExtraLong();
	event.Skip();
}

void
TrayIcon::OnAlertSettingsChanged(wxCommandEvent& event)
{
	if (event.GetInt() > 0) {
		sendAlert_ = true;
	} else {
		sendAlert_ = false;
	}
	alertTimeout_ = event.GetExtraLong();
	event.Skip();
}

void
TrayIcon::SetConnectedDaemon(wxString daemon)
{
	daemon_ = daemon;
	update();
}

wxMenu*
TrayIcon::CreatePopupMenu(void)
{
	wxMenu *menue = new wxMenu;

	menue->Append(GUI_RESTORE, _("&Restore xanoubis"));
	menue->Append(GUI_EXIT, _("E&xit xanoubis"));

	return menue;
}

void
TrayIcon::update(void)
{
	wxString tooltip;
	wxIcon *icon;
	char message[MAX_MESSAGE];
	tooltip = _("Messages: ");

	/* escalations represent the highest priority */
	if (messageEscalationCount_ > 0) {
		tooltip += wxString::Format(wxT("%d\n"),
		    messageEscalationCount_);
		icon = iconMsgQuestion_;
		sprintf(message, "Received Escalations: %d\n",
		    messageEscalationCount_);
		if (sendEscalation_) {
			if (!systemNotify("ESCALATION", message,
			    NOTIFY_URGENCY_CRITICAL, escalationTimeout_))
				wxGetApp().log(_("Couldn't send Escalation"));
		}
	} else {
		if (messageAlertCount_ > 0) {
			tooltip += wxString::Format(wxT("%d\n"),
			    messageAlertCount_);
			icon = iconMsgProblem_;
			sprintf(message, "Received Alerts: %d\n",
			    messageAlertCount_);
			if (sendAlert_) {
				if (!systemNotify("ALERT", message,
				    NOTIFY_URGENCY_NORMAL,
				    alertTimeout_))
					wxGetApp().log(
					    _("Couldn't send Alert"));
			}
		} else {
			tooltip = _("No messages\n");
			icon = iconNormal_;
			/* enforce hiding of the system notifier popup */
			notify_notification_close(notification, NULL);
			/* Process pending libnotify events. */
			wxGetApp().Yield(false);
		}
	}

	/* connection to daemon established */
	if (!daemon_.Cmp(wxT("none"))) {
		tooltip += _("not connected");
	} else {
		tooltip += _("connected with ");
		tooltip += daemon_;
	}

	SetIcon(*icon, tooltip);
}


static void
callback(NotifyNotification *notification, const char *action,
    void *user_data)
{
	assert(action != NULL);
	assert(strcmp("default", action) == 0);
	notify_notification_close(notification, NULL);

	TrayIcon* inst = (TrayIcon*)user_data;
	inst->systemNotifyCallback();
}

void
TrayIcon::systemNotifyCallback(void)
{
	wxCommandEvent  showEvent(anEVT_ESCALATIONS_SHOW);

	/* request notifications view of ESCALATIONS */
	if (messageEscalationCount_ > 0) {
		showEvent.SetInt(true);
		showEvent.SetString(wxT("ESCALATIONS"));
		wxPostEvent(AnEvents::getInstance(), showEvent);
	}

	/* request notifications view of ALERTS */
	if (messageAlertCount_ > 0) {
		showEvent.SetInt(true);
		showEvent.SetString(wxT("ALERTS"));
		wxPostEvent(AnEvents::getInstance(), showEvent);
	}
}

bool
TrayIcon::systemNotify(const gchar *module, const gchar *message,
    NotifyUrgency priority, const int timeout)
{
	char *uri = NULL;
	char buffer[MAX_PATH];
	wxString ipath = wxT("file://");
	int timeShown = (timeout * ONE_SECOND);

	NotifyUrgency messagePriority = priority;

	notify_notification_set_timeout(notification, timeShown);
	notify_notification_add_action(notification, "default", "default cb",
	    (NotifyActionCallback)callback, this, NULL);

	/* XXX ST: we disable the setting of the corresponding urgency level
	 *	   as it only renders the color area covered by the
	 *	   urgency icon (it's a libnotify bug)
	 *
	 * notify_notification_set_urgency(notification, messagePriority);
	 */

	/* determine the icon used for systemNotify */
	if (messagePriority == NOTIFY_URGENCY_LOW)
		ipath += wxGetApp().getIconPath(wxT("ModAnoubis_black_48.png"));
	if (messagePriority == NOTIFY_URGENCY_NORMAL)
		ipath += wxGetApp().getIconPath(wxT("ModAnoubis_alert_48.png"));
	if (messagePriority == NOTIFY_URGENCY_CRITICAL)
		ipath += wxGetApp().getIconPath(
		    wxT("ModAnoubis_question_48.png"));

	strlcpy(buffer, (const char*)ipath.mb_str(wxConvUTF8), sizeof(buffer));
	uri = buffer;

	/* set notification properties */
	if (message != NULL) {
		notify_notification_update(notification, module, message, uri);

		if (!notify_notification_show (notification, NULL))
			return false;
		/* Process pending libnotify events. */
		wxGetApp().Yield(false);

	} else {
		return false;
	}

	return true;
}
